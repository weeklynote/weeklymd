## 红黑二叉树
以下关于红黑二叉树的介绍来自** [百度百科-红黑树](http://baike.baidu.com/link?url=b1exd5YCzZ4fjeNBysEtpJ81ssM6S7KJQO21egYHHZ-iYHyKbL92VRSuT2JxYmrDKuzy6LxwUoId7ITlRzRGuA-FywMgq-lSwbMOLcQCXkxIzqeBLq7fBQnMsFri_lwR) **。  
以下的分析过程通过阅读**[TraaMap](https://github.com/weeklynote/weeklymd/blob/master/java/tree_map.md)**源码进行整理。
#### 数据结构
红黑树的统计性能要好于平衡二叉树(AVL-树)，因此，红黑树在很多地方都有应用。在C++ STL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。其他平衡树还有：AVL，SBT，伸展树，TREAP 等等。
#### 树的旋转
当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。  
为了保持红黑树的性质，我们可以通过对树进行旋转，即修改树中某些结点的颜色及指针结构，以达到对红黑树进行插入、删除结点等操作时，红黑树依然能保持它特有的性质  
####性质
对于任何有效的红黑树有如下性质:
1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶节点（NIL节点，空节点）是黑色的。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。  

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。  
要知道为什么这些特性确保了这个结果，注意到**性质4**导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。  
在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点不包含数据。用这种范例表示红黑树是可能的，但是这会改变一些属性并使算法复杂。为此，本文中我们使用**"nil 叶子"**或**"空(null)叶子"**，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好象同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。
#### 术语  
所有数据块都存储在节点中，这些节点中的某一个节点总是担当起始位置的功能，它不是任何节点的儿子，我们称之为**根节点或根**。它有最多两个儿子，所有这些儿子都可以有自己的儿子，以此类推。这样根节点就有了把它连接到在树中任何其他节点的路径。  
如果一个节点没有儿子，我们称之为**叶子节点**，因为在直觉上它是在树的边缘上。子树是从特定节点可以延伸到的树的某一部分，其自身被当作一个树。在红黑树中，叶子被假定为**null或空**。  
#### 用途  
红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如即时应用中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。  
红黑树在函数式编程中也特别有用，在这里它们是最常用的持久数据结构之一，它们用来构造关联数组和集合，在突变之后它们能保持为以前的版本。除了**O(log n)**的时间之外，红黑树的持久版本对每次插入或删除需要**O(log n)**的空间。  
红黑树是**2-3-4树**的一种等同。换句话说，对于每个**2-3-4树**，都存在至少一个数据元素是同样次序的红黑树。在**2-3-4树**上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得**2-3-4树**成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍**2-3-4树**的原因，尽管**2-3-4树**在实践中不经常使用。
#### 操作  
在红黑树上只读操作不需要对用于二叉查找树的操作做出修改，因为它也是二叉查找树。但是，在插入和删除之后，红黑属性可能变得违规。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保持为 O(log n) 次，但是它导致了非常复杂的操作。
###### 左旋  
增加左树的高度而减少右树的高度。  
###### 右旋  
较左旋，反之。  
###### 重新着色  
对节点的重新着色，使之满足红黑树的相关性质。  
###### 插入  
**请注意待插入的节点总是红色节点**。
我们约定：待插入的节点叫做插入节点；带插入节点的父节点叫做父节点；带插入节点的父节点的父节点叫做爷爷节点；待插入节点的父节点的兄弟节点叫做兄弟节点；用来替换进行删除的节点叫做替换节点。  
##### 插入节点作为根节点  
这种情况直接插入节点即可。 **[示例](http://)**  
##### 父节点为黑色  
这种情况插入节点不会影响红黑树的平衡，所以直接插入即可。**[示例](http://)**  
##### 父节点为红色，并且兄弟节点为红色  
此时根据红黑树的平衡性质，爷爷节点一定为黑色。 并且不管父节点是左孩子还是右孩子都是等效的。  
此时只需要将父节点与兄弟节点染黑，将爷爷节点染红。然后将爷爷节点作为新的节点继续向上做平衡操作。**[示例](http://)**  
##### 父节点为红色，且为爷爷节点的左孩子，并且兄弟节点为黑色，插入节点是父节点的左孩子。  
此时将父节点染黑，爷爷节点染红，以爷爷节点为基础做一次右旋即可。**[示例](http://)**  
##### 父节点为红色，且为爷爷节点的左孩子，并且兄弟节点为黑色，插入节点是父节点的右孩子  
此时以父节点为基点做一次左旋，在按照上述步骤进行一次操作。**[示例](http://)**  
##### 父节点为红色，且为爷爷节点的右孩子，并且兄弟节点为黑色，插入节点是父节点的右孩子  
将父节点染黑，爷爷节点染红，以爷爷节点为基点做一次左旋。  **[示例](http://)**  
##### 父节点为红色，且为爷爷节点的右孩子，并且兄弟节点为黑色，插入节点是父节点的左孩子  
以父节点为基点做一次右旋，在执行上述操作。**[示例](http://)**  
###### 删除  
删除相对于插入显得更加复杂，删除的逻辑并不是直接删除，而是通过替换之后在直接删除节点。
我们约定：待删除的节点叫做删除节点；待删除节点的父节点叫做父节点；待删除节点的父节点的兄弟节点叫做兄弟节点。
##### 如果删除节点为根节点
此时直接删除，将**root**置空即可，这种情况很好理解。  
##### 如果删除节点只有一个孩子(不管是左孩子还是右孩子)  
如果此时删除的是根节点，那么直接将根节点的孩子节点作为根节点  **[示例](http://)**。  
如果删除节点是父节点的左孩子，那么将父节点的左孩子指向删除节点的孩子  **[示例](http://)**。  
如果删除节点是父节点的右孩子，那么将父节点的右孩子指向删除节点的孩子  **[示例](http://)**。  
**最后将删除节点的父节点、左孩子、右孩子置空，即达到类似删除的效果。**  
最后需要注意如果删除节点为黑色，由此可以推断删除节点的孩子必然为红色，此种情况为了保持**红黑树的平衡**只需要将删除节点的孩子染黑即可。**[示例](http://)**
##### 如果删除节点有两个孩子
首先需要找到删除节点的继承者，这里的规则是**查找删除节点右孩子的最左子节点或者第一个向右的祖先**。  
然后将替换节点的key、value赋值给删除节点，将**删除节点指向替换节点**。
当替换节点为删除节点右孩子的最左子节点时，此时可以推论出替换节点无孩子节点或有一个红色右节点。
- 当替换节点无孩子时，将替换节点的父节点的对应孩子置空。如果替换节点为黑色，此时删除会影响平衡，需要重新着色。
- 当替换节点存在一个红色右节点时，只需要将替换节点的父节点的右孩子指向替换节点的红色右孩子节点。如果替换节点为黑色需要重新着色。

当替换节点为第一个向右的祖先时，这个情况从**[TreeMap](https://github.com/weeklynote/weeklymd/blob/master/java/tree_map.md)**的源码中查看还不清楚在什么情况下会遇到这种情况。TODO
###### 获取最大最小的元素  
因为红黑树在插入过程中本身是有序的，所以在查找元素时，可以直接根据**root**来确定最大最小值的位置，根据二叉树的性质，左边为小值，右边为大值；那么可以得出结论：最左边为最小值；最右边为最大值。因此遍历**root**根节点的链表就可以拿到最大最小值。  
###### 遍历过程(Iterator)  
从最小值(最左子树)开始遍历，如果左子树遍历完毕则需要查找第一个向右的父节点。然后继续查找父节点的左子树，如此反复，**可以参考普通二叉树的遍历来理解这个过程**。尤其需要注意在遍历完左边的最右节点时，需要查找到左边树中第一个向右的祖先节点，此时遍历的下一个值将指向根节点。然后开始遍历右子树，这个过程设计得相当巧妙。可以通过**[TreeMap](https://github.com/weeklynote/weeklymd/blob/master/java/tree_map.md)**来体验这种设计实现过程。  



























## Class Paths
ProGuard可以接收广泛使用的类路径来指定输入和输出文件，类路径可以包含多个条目，多个条目之前使用按照惯例的路径分隔符隔开(Unix系统使用“：”，Windows系统使用“；”)，每个条目的顺序决定了他们的优先级。
为了防止重复，通常情况下，每个输入条目大致如下：
> 一个类文件或资源文件
> 一个jar文件，包含以上任意内容
> 一个war文件，包含以上任意内容
> 一个ear文件，包含以上任意内容
> 一个zip文件，包含以上任意内容
> 一个目录，包含以上任意内容

直接指定类文件和资源文件的路径会被忽略，所以类文件一般情况下属于jar文件、war文件、ear文件、zip文件或目录的一部分。另外，类文件的路径最好不要在目录内添加任何额外的前缀。
每个输出条目可以是以下内容：
> jar文件，包含所有的处理过的类文件和资源文件
> war文件，包含以上描述的任意内容
> ear文件，包含以上描述的任意内容
> zip文件，包含以上描述的任意内容
> 目录，包含以上描述的任意内容

当在书写输出条目时，ProGuard会以一种合理的方式打包，即根据需要重新输入条目。将一切内容都输出到输出目录是最直接的选择:输出目录将包含一个完整的输入条目的重建。包装几乎可以任意复杂的:你可以处理整个应用程序,连同它的文档打包成一个zip文件,重新作为一个zip文件输出。
文件和目录的指定请参考**[file name usage](https://github.com/weeklynote/weeklymd/blob/master/proguard/file-names.md)**。
另外，ProGuard提供基于全路径的类路径和内容过滤。每个类路径条目可以在紧随其后的括号之间使用多达5种文件过滤器。
> 过滤zip名文件
> 过滤war名文件
> 过滤ear名文件
> 过滤jar名文件
> 过滤类文件和资源名文件

如果指定了少于5种过滤器，那就假定只针对后面的过滤类型。空的过滤器是被忽略的。正规的一个路径过滤器应该如下这样。
```
classpathentry([[[[zipfilter;]earfilter;]warfilter;]jarfilter;]filefilter)
```
方括号[]意味着内容是可选的。
比如："rt.jar(java/\*\*.class,javax/\*\*.class)"匹配rt.jar文件中的所有java和javax目录中的文件。
比如："input.jar(!\*\*.gif,images/\*\*)"匹配input.jar中的所有images目录中的文件，但是gif文件除外。
请注意不同的过滤器被使用到所有的文件类型，与input的嵌套等级无关(即不管input是否包含过滤类型),它们是可相互交叉的。
比如："input.war(lib/\*\*.jar,support/\*\*.jar;\*\*.class,\*\*.gif)"只会考虑input.war文件中lib和support目录下的jar文件，而不是其他jar文件。过滤器会会匹配遇到的所有class文件和gif文件。
过滤器允许包含无限数量的包层级和重新打包的层级。